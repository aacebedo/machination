#!/usr/bin/env python
import argparse
import logging
import os
import yaml
from   enum import Enum
import random
import socket
import fcntl
import struct
import array
import sys
import copy
import getpass

from logging import StreamHandler
from platform import architecture
from meld.vc.svk import NULL
from ipaddr import IPAddress, _IPAddrBase

formatter = logging.Formatter('%(message)s')
strHandler = StreamHandler()
strHandler.setLevel(logging.DEBUG)
strHandler.setFormatter(formatter)

logger = logging.getLogger()
logger.setLevel(logging.DEBUG)
logger.addHandler(strHandler)

MACHINATION_INSTALLDIR = os.path.join(os.path.dirname(os.path.realpath(__file__)),"..")
MACHINATION_WORKDIR = os.path.join(os.path.expanduser("~"),".machination")

class InvalidMachineTemplateError:
    _message = ""
    def __init__(self, message):
        self._message = message
    
    def __str__(self):
        return repr(self._message)


class StringifiedEnum(Enum):
        
    def __str__(self):
        return str(self.value)

class Provider(StringifiedEnum):
    Docker = "Docker"
     
class Provisioner(StringifiedEnum):
    Ansible = "Ansible"
    
class Architecture(StringifiedEnum):
    x86 = "i386"
    x64 = "x64"
   
class NetworkInterface(yaml.YAMLObject):
    yaml_tag = "!NetworkInterface"
    _ipAddr = None
    _macAddr = None
    _hostname = None
        
    def __init__(self,ipAddr, macAddr,hostname=None):
        self._ipAddr = ipAddr
        self._macAddr = macAddr
        self._hostname = hostname

    def getIPAddr(self):
        return self._ipAddr
    
    def setIPAddr(self,val):
        self._ipAddr = val
        
    def getMACAddr(self):
        return self._macAddr
    
    def setMACAddr(self,val):
        self._macAddr = val
    
    def getHostname(self):
        return self._hostname
    
    def setHostname(self,val):
        self._hostname = val
            
    def __str__(self):
        res = ""
        if self._hostname != None :
            res = self._hostname + "|"
            
        return res + self.getIPAddr()+"|"+self.getMACAddr()
    
    @classmethod
    def to_yaml(cls, dumper, data):
        representation = {
                           "ipaddr" : data.getIPAddr(),
                           "macaddr" : data.getMACAddr()
                           }
        if data.getHostname()!=None:
            representation["hostname"] = data.getHostname()
        
        return dumper.represent_mapping(data.yaml_tag,representation)    
        
    
class MachineInstance(yaml.YAMLObject):
    yaml_tag = '!MachineInstance'
    name = None
    path = None
    template = None
    provisioner = None  # Provisioner.Ansible
    provider = None  # Provider.Ansible    
    host_interface = None
    guest_interfaces  = None
    arch = None
    
    def __init__(self, name, path, template, arch, provider, provisioner, host_interface, guest_interfaces):
        self.name = name
        self.path = path
        self.template = template
        self.arch = arch
        self.provider = provider
        self.provisioner = provisioner
        self.guest_interfaces = guest_interfaces
        self.host_interface = host_interface        
    
    def instantiate(self):
        if not os.path.exists(self.getPath()):
            os.makedirs(self.getPath())
  
        if not os.path.islink(os.path.join(self.getPath(),"Vagrantfile")):
            os.symlink(os.path.join(MACHINATION_INSTALLDIR,"share","machination","vagrant","Vagrantfile"),os.path.join(self.getPath(),"Vagrantfile"))
        else:
            v = raw_input("Vagrant file already exists in the indicate folder do you want to overwrite it ? [Y/n]: ")
            
        configFile = yaml.dump(self)
        file = open(os.path.join(self.getPath(),"config.yml"),"w+")
        file.write(configFile)
        file.close()
        
    def getPath(self):
        return self.path
            
    def getName(self):
        return self.name     
    
    @classmethod
    def to_yaml(cls, dumper, data):           
        representation = {
                               "name" : data.name,
                               "path" : data.path,
                               "template" : data.template.getName(),
                               "arch" : str(data.arch),
                               "provider" : str(data.provider),
                               "provisioner" : str(data.provisioner),
                               "host_interface" : data.host_interface,
                               "guest_interfaces" : data.guest_interfaces,
                               "volumes" : []                     
                               }
        node = dumper.represent_mapping(data.yaml_tag,representation)    
        return node
    
    @classmethod
    def from_yaml(cls, loader, node):
        representation = loader.construct_mapping(node)        
        return MachineInstance(representation['name'], 
                               representation['path'], 
                               representation["template"],
                               representation["arch"], 
                               representation["provider"],
                               representation["provisioner"], 
                               representation["host_interface"], 
                               representation["guest_interfaces"])

class RegistryManager:
    
    @staticmethod
    def loadRegistry():
        if not os.path.exists(MACHINATION_WORKDIR):
            os.makedirs(MACHINATION_WORKDIR)
        file = open(os.path.join(MACHINATION_WORKDIR,"instance_registry.yml"),"r")
        val = yaml.load(file)        
        file.close()
        return val
        
    @staticmethod
    def saveRegistry(registry):
        if not os.path.exists(MACHINATION_WORKDIR):
            os.makedirs(MACHINATION_WORKDIR)
             
        file = open(os.path.join(MACHINATION_WORKDIR,"instance_registry.yml"),"w+")
        file.write( yaml.dump(registry,default_flow_style=False))
        file.close()

class MachineInstanceRegistry(yaml.YAMLObject):
    yaml_tag = "!MachineInstanceRegistry"
    instances = []
    
    def __init__(self, instances = []):  
        self.instances = instances
    
    def getInstanceReferences(self):
        return self.instances
    
    def addInstanceReference(self,instancePath):
        self.instances.append(instancePath)
        
    def removeInstanceReference(self,instancePath):
        self.instances.remove(instancePath)
        
    def loadInstanceDetail(self,instancePath):
        stream = open(os.path.join(instancePath,"config.yml"))
        instance = yaml.load(stream)
        return instance
        
    @classmethod
    def to_yaml(cls, dumper, data):           
        representation = {
                               "instances" : data.instances,                                                  
                               }
        node = dumper.represent_mapping(data.yaml_tag,representation)    
        return node
    
    @classmethod
    def from_yaml(cls, loader, node):
        representation = loader.construct_mapping(node)        
        return MachineInstanceRegistry(representation['instances'])
        
class MachineTemplate:
    path = None
    desc = None
    _provisioners = []
    _providers = []
    _interfaces = []
    _archs = []
    _guestInterfaces = []
    _hostInterface = None
      
    def __init__(self, templateFile):                                              
        self.path = templateFile
        stream = open(self.path)
        self.desc = yaml.load(stream)        
        if "archs" in self.desc.keys():
            for p in self.desc["archs"]:  
                if not p in Architecture.__members__.keys():
                    raise InvalidMachineTemplateError("arch value")
                else:
                    self._archs.append(Architecture[p])
        else:
            raise InvalidMachineTemplateError("archs")
        
        if  "providers" in self.desc.keys() and isinstance(self.desc["providers"], list) and len(self.desc["providers"]) :
            for p in self.desc["providers"]:
                if not p in Provider.__members__.keys():
                    raise InvalidMachineTemplateError("provider value")
                else:
                    self._providers.append(Provider[p])
        else:
            raise InvalidMachineTemplateError("providers")        
                   
        if "provisioners" in self.desc.keys() and isinstance(self.desc["provisioners"], list) and len(self.desc["provisioners"]) != 0 :
            for p in self.desc["provisioners"]:
                if not p in Provisioner.__members__.keys():
                    raise InvalidMachineTemplateError("provisioners value")
                else:
                    self._provisioners.append(Provisioner[p])
        else:
            raise InvalidMachineTemplateError("provisioners")

        if "host_interface" in self.desc.keys() and isinstance(self.desc["host_interface"], str) or self.desc["host_interface"] == None:
            self._hostInterface = self.desc["host_interface"]
        else:
            raise InvalidMachineTemplateError("host_interface")

        if "guest_interfaces" in self.desc.keys() and isinstance(self.desc["guest_interfaces"], list):
            for p in self.desc["guest_interfaces"]:
               
                if p.has_key("ipaddr") and p.has_key("macaddr"):
                    if p.has_key("hostname"):
                        self._guestInterfaces.append(NetworkInterface(p["ipaddr"],p["macaddr"],p["hostname"]))
                    else:
                        self._guestInterfaces.append(NetworkInterface(p["ipaddr"],p["macaddr"]))
                        
                else:
                    raise InvalidMachineTemplateError("size")
        else:
            raise InvalidMachineTemplateError("guest_interfaces")
        
        
    def getName(self):
        fileName = os.path.basename(self.path)
        return os.path.splitext(fileName)[0]
    
    def getPath(self):
        return self.path
    
    def getArchs(self):
        return self._archs
    
    def getProviders(self):
        return self._providers
    
    def getProvisioners(self):
        return self._provisioners

    def getHostInterface(self):
        return self._hostInterface
    
    def getGuestInterfaces(self):
        return self._guestInterfaces
   

registry = MachineInstanceRegistry()

def randomMAC():
    mac = [ 0x00, 0x16, 0x3e,
        random.randint(0x00, 0x7f),
        random.randint(0x00, 0xff),
        random.randint(0x00, 0xff) ]
    return ':'.join(map(lambda x: "%02x" % x, mac))
   
def listAvailableMachineTemplates():
    logger.debug("List machine templates")
    paths = listPath(os.path.join(MACHINATION_INSTALLDIR,'share','machination', 'machines'))
    machineTemplates = {}
    for f in paths:
        if os.path.isfile(f) and  os.path.splitext(os.path.basename(f))[1] == ".yml":
            machine = MachineTemplate(f)
            machineTemplates[machine.getName()] = machine
    return machineTemplates
            
def listPath(d):
    return [os.path.join(d, f) for f in os.listdir(d)]

def listProvisionerTemplates(args):
  logger.debug("List templates for provisioner " + args.provisioner)
  listAnsibleTemplates()

def listAnsibleTemplates():
  logger.debug("List ansible template")
  paths = listPath(os.path.join(MACHINATION_INSTALLDIR,'share','machination', 'provisioner', 'playbooks'))
  data = {'name': [], 'version': [], 'path': [], 'provisioner': []}
  provisioners = listAvailableMachineTemplates();
  # data = []
  for f in provisioners:
    data['name'].append(f.getName())
    data['version'].append('1.0')
    data['path'].append(f.getPath())
    data['provisioner'].append('ansible')
    
  name_col_width = max(len(word) for word in data['name']) + len("Name") + 2 
  version_col_width = max(len(word) for word in data['version']) + len("Version") + 2
  path_col_width = max(len(word) for word in data['path']) + len("Path") + 2
  pro_col_width = max(len(word) for word in data['provisioner']) + len("Provisioner") + 2

  logger.info("Name".ljust(name_col_width) + "Version".ljust(version_col_width) + "Path".ljust(path_col_width) + "Provisioner".ljust(pro_col_width))

  for row in range(0, len(data['name'])):
      print data['name'][row].ljust(name_col_width) + data['version'][row].ljust(version_col_width) + data['path'][row].ljust(path_col_width) + data['provisioner'][row].ljust(pro_col_width)
 
def listInstances(args):
    
    print os.getenv("SUDO_USER")
    logger.debug("List instances")
    registry = RegistryManager.loadRegistry()
    data = {'name': [], 'path': []}
      
    for i in registry.getInstanceReferences():
        iDetail = registry.loadInstanceDetail(i)
        data['name'].append(iDetail.getName())
        data['path'].append(iDetail.getPath())
        
    name_col_width = max(len(word) for word in data['name']) + len("Name") + 2 
    path_col_width = max(len(word) for word in data['path']) + len("Path") + 2
      
    logger.info("Name".ljust(name_col_width) + "Path".ljust(path_col_width))
    for row in range(0, len(data['name'])):
        print data['name'][row].ljust(name_col_width) + data['path'][row].ljust(path_col_width)

def createMachine(args):
    logger.debug("Create machine " + args.name + " from template " + args.template + " in " + args.path)
    availableMachines = listAvailableMachineTemplates()
    instance = None
    
    if args.name in availableMachines.keys():
        template = availableMachines[args.name]
        logger.debug("Creating ")
       
        hostInterface = template.getHostInterface()
        guestInterfaces = copy.deepcopy(template.getGuestInterfaces())
        arch = template.getArchs()[0]
        provider = template.getProviders()[0]   
        provisioner = template.getProvisioners()[0]
        
        if template.getHostInterface() == None:
            v = raw_input("Please enter the host interface [eth0]: ")
            if not v == "":
                hostinterface = v
            else:
                hostinterface = "eth0"
        
        i = 0
        for f in template.getGuestInterfaces():
            v = raw_input("Please enter ipaddress for the interface ["+f.getIPAddr()+"]: ")
            if not v == "":
                guestInterfaces[i].setIPAddr(v)
                
            v = raw_input("Please enter macadress for the interface: ["+f.getMACAddr()+"]" )  
            if not v == "":
                guestInterfaces[i].setMACAddr(v)
            
            if f.getHostname() != None:
                v = raw_input("Please enter hostname for the interface: ["+f.getHostname()+"]" )  
                if not v == "":
                    guestInterfaces[i].setHostname(v)
                
            i+=1
                                     
        if len(template.getArchs()) > 1 :
            archs = ""
            for a in template.getArchs():
                archs += str(a)+", "
           
            v = raw_input("Select an architecture {" + ",".join(map(str,template.getArchs())) + "} [" + arch.name + "]: ")         
            if not v == "":
                if v in Architecture.__members__.keys():
                    arch = Architecture[v]
                else:
                    raise InvalidMachineTemplateError("invalid arch")
                 
        if len(template.getProvisioners()) > 1 :
            v = raw_input("Select a provisioner {" + ','.join(map(str,template.getProvisioners())) + "} [" + provisioner + "]: ")
            if v in Provisioner.__members__.keys():
                provisioner = Provisioner[v]
            else:
                raise InvalidMachineTemplateError("invalid provisioner")
                
        if len(template.getProviders()) > 1 :
            v = raw_input("Select a provider  {" + ','.join(map(str,template.getProviders())) + "} [" + provider + "]: ")            
            if v in Provider.__members__.keys():
                provider = Provider[v]
            else:
                raise InvalidMachineTemplateError("invalid provisioner")

        logger.info("This machine will use the architecture " + str(arch))                                    
        logger.info("This machine will use the provisioner " + str(provisioner))
        logger.info("This machine will use the provider " + str(provider))
        logger.info("This machine use the host interface " + hostinterface)
        i = 0
        logger.info("This machine will have the following network interfaces :")
        for intf in guestInterfaces:            
            logger.info("\tName: eth" + str(i))            
            logger.info("\tIPAddress: " + intf.getIPAddr())
            logger.info("\tMACAddress: " + intf.getMACAddr())
            if intf.getHostname() != None:
               logger.info("\tHostname: " + intf.getHostname())
            logger.info("")
            i+=1
        
        absPath = os.path.abspath(args.path)
        instance = MachineInstance(args.name,absPath, template, arch, provider, provisioner, hostInterface, guestInterfaces)        
        registry.addInstanceReference(instance.getPath())
        instance.instantiate()
        RegistryManager.saveRegistry(registry)
        
    #print yaml.dump(instance)
 #       print all_interfaces()
 #       loaded = yaml.load(yaml.dump(instance,default_flow_style=False))
    else:
        raise InvalidMachineTemplateError(args.name)
 
def all_interfaces():
    max_possible = 128  # arbitrary. raise if needed.
    bytes = max_possible * 32
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    names = array.array('B', '\0' * bytes)
    outbytes = struct.unpack('iL', fcntl.ioctl(
        s.fileno(),
        0x8912,  # SIOCGIFCONF
        struct.pack('iL', bytes, names.buffer_info()[0])
    ))[0]
    namestr = names.tostring()
    return [namestr[i:i+32].split('\0', 1)[0] for i in range(0, outbytes, 32)]

  
def destroyMachine(args):
  logger.debug("Destroy machine " + args.name) 

def startMachine(args):
  logger.debug("Start machine " + args.name) 

def stopMachine(args):
  logger.debug("Stop machine " + args.name) 

def sshMachine(args):
  logger.debug("SSH to machine " + args.name) 


# 
# class DestroyMachine(argparse.Action):
#   # def __init__(self, option_strings, dest, nargs=None, **kwargs):
#   #  if nargs is not None:
#   #    raise ValueError("nargs not allowed")
#   #  super(ListMachines, self).__init__(option_strings, dest, **kwargs)
#   def __call__(self, parser, namespace, values, option_string=None):
#     print 'Create machine %r %r %r' % (namespace, values, option_string)
# 
# 
# class StartMachine(argparse.Action):
#   # def __init__(self, option_strings, dest, nargs=None, **kwargs):
#   #  if nargs is not None:
#   #    raise ValueError("nargs not allowed")
#   #  super(ListMachines, self).__init__(option_strings, dest, **kwargs)
#   def __call__(self, parser, namespace, values, option_string=None):
#     print 'Create machine %r %r %r' % (namespace, values, option_string)
# 
# 
# class StopMachine(argparse.Action):
#   # def __init__(self, option_strings, dest, nargs=None, **kwargs):
#   #  if nargs is not None:
#   #    raise ValueError("nargs not allowed")
#   #  super(ListMachines, self).__init__(option_strings, dest, **kwargs)
#   def __call__(self, parser, namespace, values, option_string=None):
#     print 'Create machine %r %r %r' % (namespace, values, option_string)

parser = argparse.ArgumentParser(prog="Machination", description='Machination utility, easily instantiate vagrant based machines.')

rootSubparsers = parser.add_subparsers(help='List available machines')

listParser = rootSubparsers.add_parser('list', help='List elements')
listSubparsers = listParser.add_subparsers(help='List elements')

templateSubparser = listSubparsers.add_parser('templates', help='List templates')
templateSubparser.add_argument('provisioner', choices=['ansible'], nargs='*', default='ansible', help="List templates of a provider")
templateSubparser.set_defaults(func=listProvisionerTemplates)

templateSubparser = listSubparsers.add_parser('instances', help='List instances')
templateSubparser.set_defaults(func=listInstances)


createParser = rootSubparsers.add_parser('create', help='Create the given machine in the path')
createParser.add_argument('template', help='Name of the template to create')
createParser.add_argument('name', help='Name of the machine to create')
createParser.add_argument('path', help='Path where to create the machine')
# createParser.add_argument('provisioner', choices=['ansible'], nargs='?', default='ansible', help="List templates of a provider")
createParser.set_defaults(func=createMachine)

destroyParser = rootSubparsers.add_parser('destroy', help='Destroy the given machine in the path')
destroyParser.add_argument('name', help='Name of the machine to destroy')
destroyParser.set_defaults(func=destroyMachine)

startParser = rootSubparsers.add_parser('start', help='Start the given machine')
startParser.add_argument('name', help='Name of the machine to start')
startParser.set_defaults(func=startMachine)

stopParser = rootSubparsers.add_parser('stop', help='Stop the given machine')
stopParser.add_argument('name', help='Name of the machine to stop')
stopParser.set_defaults(func=stopMachine)

sshParser = rootSubparsers.add_parser('destroy', help='SSH to the given machine')
sshParser.add_argument('name', help='Name of the machine to ssh in')
sshParser.set_defaults(func=sshMachine)

args = parser.parse_args()
args.func(args)


# v = yaml.load("""
# !MachineInstanceRegistry2
# instances: 
# - toto
# """)
# 
# print v
# test2 = MachineInstanceRegistry2()
# test2.addInstance(MachineInstance("/test","/test", None, None, None, None, None, None))
# print yaml.dump(test2, default_flow_style=False)



# print args
# print args.acculate(args.integers)
